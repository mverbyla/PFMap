methods<-paste("treats",nodes$subType[nodes$ntype=="source"][1],if(length(nodes$subType[nodes$ntype=="source"]==2)){paste("and",nodes$subType[nodes$ntype=="source"][2])},
"using the following technologies:",
uPs
)
methods
#****#****#****#****#
uPs<-paste(unique(nodes$subType[nodes$ntype=="unit process"]), collapse = ', ')
methods<-paste("treats",nodes$subType[nodes$ntype=="source"][1],if(length(nodes$subType[nodes$ntype=="source"]==2)){paste("and",nodes$subType[nodes$ntype=="source"][2])},
"using the following technologies:",
uPs,"."
)
methods<-paste("treats",nodes$subType[nodes$ntype=="source"][1],if(length(nodes$subType[nodes$ntype=="source"]==2)){paste("and",nodes$subType[nodes$ntype=="source"][2])},
"using the following technologies:",
uPs,"."
);methods
#****#****#****#****#
uPs<-paste(unique(nodes$subType[nodes$ntype=="unit process"]), collapse = ', ')
methods<-paste("treats ",nodes$subType[nodes$ntype=="source"][1],if(length(nodes$subType[nodes$ntype=="source"]==2)){paste(" and ",nodes$subType[nodes$ntype=="source"][2])},
" using the following technologies: ",
uPs,".",sep=""
);methods
nodes
unique(nodes$subType[nodes$ntype=="unit process"]
#****#****#****#****#
solved<-list(arrows=arrows[,c("us_node","ds_node","loading","flowtype","us_node_type","ds_node_type","relativeLoading")],
nodes=nodes[,c("name","ntype","subType","temperature","retentionTime","depth","useCategory","moistureContent","holdingTime","matrix","loading_output","pathogen")],
loadings=loadings,
references=references)
return(solved)
}
getLRV()
unique(nodes$subType[nodes$ntype=="unit process"]
#****#****#****#****#
solved<-list(arrows=arrows[,c("us_node","ds_node","loading","flowtype","us_node_type","ds_node_type","relativeLoading")],
nodes=nodes[,c("name","ntype","subType","temperature","retentionTime","depth","useCategory","moistureContent","holdingTime","matrix","loading_output","pathogen")],
loadings=loadings,
references=references)
return(solved)
}
getLRV()
unique(nodes$subType[nodes$ntype=="unit process"])
"facultative pond" %in% unique(nodes$subType[nodes$ntype=="unit process"])
nodes$retentionTime[nodes$subType=="anaerobic pond"]
nodes$retentionTime[nodes$subType=="anaerobic pond"]
nodes
unique(nodes$subType[nodes$ntype=="unit process"])
unique
nodes$subType[nodes$ntype=="unit process"]
methods
methods<-paste("treats ",nodes$subType[nodes$ntype=="source"][1],if(length(nodes$subType[nodes$ntype=="source"]==2)){paste("and",nodes$subType[nodes$ntype=="source"][2])},
" using the following technologies: ",
uPs,".",sep=""
);methods
methods<-paste("treats ",nodes$subType[nodes$ntype=="source"][1],if(length(nodes$subType[nodes$ntype=="source"]==2)){paste(" and",nodes$subType[nodes$ntype=="source"][2])},
" using the following technologies: ",
uPs,".",sep=""
);methods
nodes
nodes[nodes$ntype=="unit process"]
nodes[nodes$ntype=="unit process",]
#' @examples
#' getLoadings(onsiteData="http://data.waterpathogens.org/dataset/5374462b-5bb5-456f-bfc0-816ea572666d/resource/4d9e5fba-9280-4b8b-acce-d1c87952acc1/download/onsitedata_example.csv",pathogenType="Virus")
#'
#'     region     excreted to_groundwater   to_surface retained_in_soil      decayed In_Fecal_Sludge    In_Sewage  stillViable Onsite_LRV Onsite_PR
#' 1  Central 3.470412e+16   7.208736e+14 1.241347e+15     6.487862e+15 1.696317e+16    4.204900e+13 9.142680e+15 1.114695e+16       0.49    0.6788
#' 2  Kawempe 1.828207e+17   2.923315e+15 3.819070e+15     2.630984e+16 1.427235e+17    1.714675e+14 6.738060e+15 1.365191e+16       1.13    0.9253
#' 3 Makindye 2.115370e+17   5.784264e+15 7.404292e+15     5.205838e+16 1.396717e+17    1.877473e+14 6.042660e+15 1.941896e+16       1.04    0.9082
#' 4   Nakawa 1.740476e+17   4.848475e+15 5.834954e+15     4.363628e+16 1.023125e+17    1.109438e+14 1.716174e+16 2.795611e+16       0.79    0.8394
#' 5   Rubaga 2.103805e+17   4.278101e+15 5.257688e+15     3.850291e+16 1.602164e+17    2.221318e+14 9.808800e+14 1.073880e+16       1.29    0.9490
#'
getLoadings<-function(onsiteData="http://data.waterpathogens.org/dataset/5374462b-5bb5-456f-bfc0-816ea572666d/resource/4d9e5fba-9280-4b8b-acce-d1c87952acc1/download/onsitedata_example.csv",pathogenType){
df1<-read.csv(onsiteData,header=TRUE)   #bring in the inputs CSV file
pathogenGroups<-c("Virus","Bacteria","Protozoa","Helminth")
index<-which(pathogenGroups==pathogenType)
# &&&&& START GWPP Inputs &&&&&
lambdas<-c(lambdaV=0.2,lambdaB=0.3,lambdaP=0.6,lambdaH=0.99) # these lambda values are based on data from the literature (Chauret et al., 1999; Lucena et al., 2004; Ramo et al., 2017; Rose et al., 1996; Kinyua et al. 2016; Tanji et al., 2002; Tsai et al., 1998)
vzReduction<-c(vzV=0.1,vzB=0.01,vzP=0.001,vzH=0.0001) # currently assuming 1-, 2-, 3-, and 4-log reduction of viruses, bacteria, protozoa, and helminth eggs, respectively, between pits and groundwater
#persistence model in pits
persist<-read.csv("http://data.waterpathogens.org/dataset/eda3c64c-479e-4177-869c-93b3dc247a10/resource/f99291ab-d536-4536-a146-083a07ea49b9/download/k2p_persistence.csv",header=T)
persist<-persist[persist$matrix=="Fecal sludge",]
persist$ln_removal<--persist$log10_reduction*log(10)
N<-length(unique(persist$experiment_id))
persist$ind<-NA       # this will be an index variable to distinguish each independent experiment
for(j in 1:length(persist$experiment_id)){
persist$ind[j]<-which(data.frame(unique(persist$experiment_id))==persist$experiment_id[j])
}
k<-rep(NA,N);group<-rep(NA,N);addit<-rep(NA,N); pH<-rep(NA,N);urine<-rep(NA,N);moisture<-rep(NA,N);temperature<-rep(NA,N);r2<-rep(NA,N);num<-rep(NA,N);authors<-rep(NA,N)
for(z in 1:N){   #in this loop, we calculate the k value for the log linear decay:                 Ct = Co*exp(-k*t)
time<-persist[persist$ind==z,]$time_days   #get the time only for the present experiment
lnrv<-persist[persist$ind==z,]$ln_removal  #get the ln reduction only for the present experiment
# since we calculated the ln reduction, then equation gets algebraically rearranged like this:    ln(Ct/Co) = -k*t
# lnrv is ln(Ct/Co), so our linear model is like this: lnrv~time
fit<-lm(lnrv~time)
num[z]<-length(time)
r2[z]<-suppressWarnings(summary(fit)$r.squared)
k[z]<-fit$coefficients[2]
authors[z]<-paste(unique(persist[persist$ind==z,]$bib_id),as.character(unique(persist[persist$ind==z,]$authors)))
group[z]<-as.character(unique(persist[persist$ind==z,]$microbial_group))
addit[z]<-as.character(unique(persist[persist$ind==z,]$additive))
pH[z]<-as.numeric(median(persist[persist$ind==z,]$pH))
urine[z]<-as.character(unique(persist[persist$ind==z,]$urine))
moisture[z]<-as.numeric(max(persist[persist$ind==z,]$moisture_content_percent))
temperature[z]<-as.numeric(median(persist[persist$ind==z,]$temperature_celsius))
}
kPit<-data.frame(microbial_group=group,k=k,num=num,additive=addit,pH=pH,temp=temperature,moisture=moisture,urine=urine,r2=r2)
kPit=kPit[-c(30,46,47,73,204,205),] #removing data points that are outliers
kPit<-kPit[kPit$r2>0.7,] #only keeping data with good log linear fit (r2>0.7)
kPit<-kPit[kPit$k<0,] #removing any data showing growth
kPit<-kPit[kPit$num>4,] #removing any results from experiments done with fewer than 4 data points
kPit$lk<-log(-kPit$k)
kPit$ltemp<-log(kPit$temp)
fit_kPit<-lm(lk~factor(microbial_group)+factor(urine)*pH+ltemp+moisture,data=kPit)
summary(fit_kPit)
# I need to find out here how to make pitAdditive dependent on the index m (geographic location or treatment plant service area)
kValueV<-suppressWarnings(exp(predict(fit_kPit,newdata=data.frame(urine="Fresh Urine",pH=7,ltemp=log(30),moisture=80,microbial_group="Virus"))))
kValueB<-suppressWarnings(exp(predict(fit_kPit,newdata=data.frame(urine="Fresh Urine",pH=7,ltemp=log(30),moisture=80,microbial_group="Bacteria"))))
kValueP<-suppressWarnings(exp(predict(fit_kPit,newdata=data.frame(urine="Fresh Urine",pH=7,ltemp=log(30),moisture=80,microbial_group="Protozoa"))))
kValueH<-suppressWarnings(exp(predict(fit_kPit,newdata=data.frame(urine="Fresh Urine",pH=7,ltemp=log(30),moisture=80,microbial_group="Helminth"))))
kValues<-c(Virus=kValueV,Bacteria=kValueB,Protozoa=kValueP,Helminth=kValueH);kValues #the units here are 1/days
# &&&&& END GWPP Inputs &&&&&
loops<-nrow(df1)
loadings.names <- c("virus", "bacteria", "protozoa", "helminth")
loadings <- vector("list", length(loadings.names))
names(loadings) <- loadings.names
for(o in 1:4){
loadings[[o]] <- vector("list",loops)
names(loadings[[o]]) <- df1$region
}
onsite_results.names <- c("virus", "bacteria", "protozoa", "helminth")
onsite_results <- vector("list", length(onsite_results.names))
names(onsite_results) <- onsite_results.names
loadings<-loadings[[index]]
onsite_results<-onsite_results[[index]]
myJMP1<-read.csv("http://data.waterpathogens.org/dataset/86741b90-62ab-4dc2-941c-60c85bfe7ffc/resource/9113d653-0e10-4b4d-9159-344c494f7fc7/download/jmp_assumptions.csv",header=T)
for(m in 1:loops){  # m is an index for region or subregion
df<-df1[m,]
myJMP<-myJMP1
region<-df$region
sheddingRate<-df$sheddingRate # this needs to be the number of pathogens shed per INFECTED person per day
prevalence<-df$prevalence # this needs to be the percentage of the population actively shedding
population<-df$population
flushSewer<-df$flushSewer
flushSeptic<-df$flushSeptic
flushPit<-df$flushPit
flushOpen<-df$flushOpen
flushUnknown<-df$flushUnknown
pitSlab<-df$pitSlab
pitNoSlab<-df$pitNoSlab
compostingTwinSlab<-df$compostingTwinSlab
compostingTwinNoSlab<-df$compostingTwinNoSlab
compostingToilet<-df$compostingToilet
bucketLatrine<-df$bucketLatrine
containerBased<-df$containerBased
hangingToilet<-df$hangingToilet
openDefecation<-df$openDefecation
other<-df$other
isShared<-df$isShared
sewerLeak<-df$sewerLeak
emptied<-df$emptied
isWatertight<-df$isWatertight
hasLeach<-df$hasLeach
coverBury<-df$coverBury
emptiedTreatment<-df$emptiedTreatment
emptiedLast<-df$emptiedLast
emptyFrequency<-df$emptyFrequency
soilType<-df$soilType
pitAdditive<-df$pitAdditive
pitAge<-df$pitAge
liquidWaste<-df$liquidWaste
infantStools<-df$infantStools
flushElsewhere<-df$flushElsewhere
pitVIP<-df$pitVIP
pitTraditional<-df$pitTraditional
otherLatrine<-df$otherLatrine
otherImproved<-df$otherImproved
otherUnimproved<-df$otherUnimproved
dontKnow<-df$dontKnow
daysperyear<-366
decayTimeUNSAFE<-daysperyear  # this is the average time interval between unsafe pit emptying events (default is set to 1 year, assuming it happens at the beginning of the rainy season)
myJMP$percentage<-c(flushSewer,
flushSeptic+otherImproved,
flushPit,
flushOpen+flushElsewhere+otherUnimproved,
flushUnknown,
pitSlab+pitVIP+pitTraditional+otherLatrine,
pitNoSlab,
compostingTwinSlab,
compostingTwinNoSlab,
compostingToilet,
bucketLatrine,
containerBased,
hangingToilet,
openDefecation,
other+dontKnow);myJMP
myJMP$tankWatertight<-c(0,isWatertight,rep(0,13))
myJMP$leachSystem<-c(0,hasLeach,rep(0,13))
myJMP$cover_bury<-c(0,coverBury,coverBury,0,0,coverBury,0,coverBury,0,coverBury,0,coverBury,0,0,coverBury)
myJMP$tankOutlet<-myJMP$flushOnsite*(1-myJMP$leachSystem)
myJMP$DRY_TOILET<-(1-myJMP$flushSewer)*(1-myJMP$flushOnsite)
myJMP$FLUSH_TOILET_sewered<-myJMP$flushSewer
myJMP$FLUSH_TOILET_containedNotWT<-(1-myJMP$flushSewer)*myJMP$flushOnsite*(1-myJMP$tankWatertight)
myJMP$FLUSH_TOILET_containedWT_noLeach<-myJMP$flushOnsite*myJMP$tankWatertight*myJMP$tankOutlet
myJMP$FLUSH_TOILET_containedWT_Leach<-myJMP$flushOnsite*myJMP$tankWatertight*myJMP$leachSystem
myJMP$safeEmpty<-emptiedTreatment*(1-myJMP$FLUSH_TOILET_sewered-myJMP$cover_bury)
myJMP$unsafeEmpty<-1-myJMP$FLUSH_TOILET_sewered-myJMP$cover_bury-myJMP$safeEmpty #includes "flooding out" latrines in the rainy season
# ^^^^^ END JMP data calculations ^^^^^
loadings[[m]]<-data.frame(myJMP[,c("name","classification","percentage","initiallyContained","flushSewer","FLUSH_TOILET_containedNotWT","FLUSH_TOILET_containedWT_Leach","FLUSH_TOILET_containedWT_noLeach","unsafeEmpty","safeEmpty")])
# &&&&& START PFM Onsite Calculations &&&&&
i=index
loadings[[m]]$lamda<-c(0,lambdas[i],lambdas[i],0,0,1,1,1,1,1,0,1,0,0,0)
loadings[[m]]$excreted<-sheddingRate*round(round(population*loadings[[m]]$percentage)*prevalence)*daysperyear  #Eq. 1: Pathogen Loading Model (Column J) #/year
loadings[[m]]$initContained<-loadings[[m]]$excreted*loadings[[m]]$initiallyContained  #Eq. 2: Number Initially Contained (Column O) #/year
loadings[[m]]$notContained<-loadings[[m]]$excreted-loadings[[m]]$initContained
loadings[[m]]$inLiquid<-loadings[[m]]$initContained*(1-loadings[[m]]$lamda)*(1-loadings[[m]]$flushSewer)
loadings[[m]]$inSolid<-loadings[[m]]$initContained*loadings[[m]]$lamda*(1-loadings[[m]]$flushSewer)
loadings[[m]]$toGW<-loadings[[m]]$inLiquid*(loadings[[m]]$FLUSH_TOILET_containedNotWT+loadings[[m]]$FLUSH_TOILET_containedWT_Leach)*vzReduction[[i]]   #Eq. 5: Number Reaching Groundwater (Column AI) #/year
loadings[[m]]$inVZ<-loadings[[m]]$inLiquid*(loadings[[m]]$FLUSH_TOILET_containedNotWT+loadings[[m]]$FLUSH_TOILET_containedWT_Leach)-loadings[[m]]$toGW
loadings[[m]]$coveredBuried<-loadings[[m]]$inSolid*coverBury
loadings[[m]]$totalSubsurface<-loadings[[m]]$inVZ+loadings[[m]]$coveredBuried
loadings[[m]]$toSW_liq<-loadings[[m]]$inLiquid*loadings[[m]]$FLUSH_TOILET_containedWT_noLeach+loadings[[m]]$initContained*loadings[[m]]$flushSewer*sewerLeak
for(j in 1:15){  # decay for toilets with UNSAFE emptying practices
if(j==8|j==9){ #i.e., if there are twin pits
remaining<-exp(-kValues[i]*(seq(decayTimeUNSAFE,1,by=-1)+decayTimeUNSAFE-1))
remaining<-replace(remaining,which(remaining<0.001),0.001)
loadings[[m]]$toSW_sol[j]<-sum(remaining*loadings[[m]]$inSolid[j]/daysperyear*loadings[[m]]$unsafeEmpty[j])
loadings[[m]]$unsafeDecay[j]<-sum((1-remaining)*loadings[[m]]$inSolid[j]/daysperyear*loadings[[m]]$unsafeEmpty[j])
}else{ #i.e., there is only a single pit
remaining<-exp(-kValues[i]*seq(decayTimeUNSAFE,1,by=-1))
remaining<-replace(remaining,which(remaining<0.001),0.001)
loadings[[m]]$toSW_sol[j]<-sum(remaining*loadings[[m]]$inSolid[j]/daysperyear*loadings[[m]]$unsafeEmpty[j])
loadings[[m]]$unsafeDecay[j]<-sum((1-remaining)*loadings[[m]]$inSolid[j]/daysperyear*loadings[[m]]$unsafeEmpty[j])
}
}
loadings[[m]]$toWWTP<-loadings[[m]]$initContained*loadings[[m]]$flushSewer*(1-sewerLeak)
for(j in 1:15){  # decay for toilets with SAFE emptying practices
if(j==8|j==9){ #i.e., if there are twin pits
remaining<-exp(-kValues[i]*(seq(daysperyear*emptyFrequency,1,by=-1)+daysperyear*emptyFrequency-1))
remaining<-replace(remaining,which(remaining<0.001),0.001)
loadings[[m]]$toFSTP[j]<-sum(remaining*loadings[[m]]$inSolid[j]/daysperyear*loadings[[m]]$safeEmpty[j])/emptyFrequency
# decay = Σ [ (1 - exp(-0.7559879*10)) * 4.4e17/366 * 1 ]
loadings[[m]]$safeDecay[j]<-sum((1-remaining)*loadings[[m]]$inSolid[j]/daysperyear*loadings[[m]]$safeEmpty[j])/emptyFrequency
}else{   #i.e., there is only a single pit
remaining<-exp(-kValues[i]*(seq(daysperyear*emptyFrequency,1,by=-1)))
remaining<-replace(remaining,which(remaining<0.001),0.001)
loadings[[m]]$toFSTP[j]<-sum(remaining*loadings[[m]]$inSolid[j]/daysperyear*loadings[[m]]$safeEmpty[j])/emptyFrequency
loadings[[m]]$safeDecay[j]<-sum((1-remaining)*loadings[[m]]$inSolid[j]/daysperyear*loadings[[m]]$safeEmpty[j])/emptyFrequency
}
}
loadings[[m]]$totalDecayed<-loadings[[m]]$unsafeDecay+loadings[[m]]$safeDecay
loadings[[m]]$toSW<-loadings[[m]]$notContained+loadings[[m]]$toSW_sol+loadings[[m]]$toSW_liq
loadings[[m]]$stillViable<-(loadings[[m]][,"toGW"]+loadings[[m]][,"toSW"]+loadings[[m]][,"toWWTP"]+loadings[[m]][,"toFSTP"])
loadings[[m]]$LRV_byTech<-round(log10(loadings[[m]][,"excreted"]/loadings[[m]][,"stillViable"]),2)
LRV_byTechnology <- as.data.frame(t(loadings[[m]]$LRV_byTech))
colnames(LRV_byTechnology) <- paste("LRV_",loadings[[m]]$name,sep="")
LRV_byTechnology[is.na(LRV_byTechnology)]<-NA
### CALCULATE EMISSIONS ###
excreted=sum(loadings[[m]]$excreted)
to_groundwater=sum(loadings[[m]]$toGW)
to_surface=sum(loadings[[m]]$toSW)
retained_in_soil=sum(loadings[[m]]$totalSubsurface)
decayed=sum(loadings[[m]]$totalDecayed)
In_Sewage=sum(loadings[[m]]$toWWTP)
In_Fecal_Sludge=sum(loadings[[m]]$toFSTP)
loadings[[m]]<-loadings[[m]][,c("name","classification","percentage","excreted","toGW","toSW","totalSubsurface","totalDecayed","toFSTP","toWWTP","stillViable","LRV_byTech")]
names(loadings[[m]])<-c("id","sanitationTechnology","percentage","excreted","toGroundwater","toSurface","inSubsurface","decayed","fecalSludge","sewerage","stillViable","onsiteLRV")
newRow<-data.frame(region=df$region,excreted,to_groundwater,to_surface,retained_in_soil,decayed,
In_Fecal_Sludge,In_Sewage,stillViable=(to_groundwater+to_surface+In_Sewage+In_Fecal_Sludge),
Onsite_LRV=round(log10(excreted/(to_groundwater+to_surface+In_Sewage+In_Fecal_Sludge)),2),
Onsite_PR=round(((excreted-(to_groundwater+to_surface+In_Sewage+In_Fecal_Sludge))/excreted),4))
onsite_results=rbind(onsite_results,newRow)
}
return(list(detailed=loadings,summary=onsite_results))
}
getLoadings()
getLoadings(pathogenType = "Virus")
getwd()
getLoadings(onsiteData = "myOnsiteData.csv", pathogenType = "Virus")
getLoadings(onsiteData = "myOnsiteData.csv", pathogenType = "Virus")
devtools::install_github('mverbyla/pathogenflows')
remove.packages("pathogenflows")
devtools::install_github('mverbyla/pathogenflows')
remove.packages("pathogenflows")
devtools::install_github('mverbyla/pathogenflows')
#' This function predicts the pathogen log reduction value for a wastewater or fecal sludge treatment plant sketched using the K2P Sketcher Tool (http://tools.waterpathogens.org/sketcher/)
#' @param sketch A JSON file containing information about the wastewater or fecal sludge treatment plant. This file must be in a very specific format and can be created using the K2P Sketcher Tool (http://tools.waterpathogens.org/sketcher/)
#' @param inFecalSludge Number of pathogens conveyed each year to the treatment plant in fecal sludge
#' @param inSewage Number of pathogens conveyed each year to the treatment plant in sewerage
#' @param pathogenType Pathogen group of interest (Virus, Bacteria, Protozoa, Helminth)
#' @keywords pathogens
#' @export
#' @examples
#' getLRV(mySketch="http://data.waterpathogens.org/dataset/1c681f80-82fa-4ed8-a572-cb98c886781a/resource/a87a552b-2f7c-4267-ac07-526eba1f4b68/download/lubigisewageandfecalsludgetreatmentsystem.json",pathogenType="Virus",inFecalSludge=10000000000,inSewage=10000000000)
#'
getLRV<-function(mySketch="http://data.waterpathogens.org/dataset/1c681f80-82fa-4ed8-a572-cb98c886781a/resource/a87a552b-2f7c-4267-ac07-526eba1f4b68/download/lubigisewageandfecalsludgetreatmentsystem.json"
,
myLRVdata="http://data.waterpathogens.org/dataset/eda3c64c-479e-4177-869c-93b3dc247a10/resource/9e172f8f-d8b5-4657-92a4-38da60786327/download/treatmentdata.csv"
,
pathogenType="Virus"
,
inFecalSludge=10000000000
,
inSewage=10000000000
){
k2pdata<-read.csv(myLRVdata,header=T)
suppressWarnings(k2pdata$SQRTlrv<-sqrt(k2pdata$lrv))
suppressWarnings(k2pdata$llrv<-log(k2pdata$lrv))
suppressWarnings(k2pdata$pathogen<-k2pdata$pathogen_group)
suppressWarnings(k2pdata$lhrt<-log(k2pdata$hrt_days))
suppressWarnings(k2pdata$SQRThrt<-sqrt(k2pdata$hrt_days))
suppressWarnings(k2pdata$SQRTht<-sqrt(k2pdata$holdingtime_days))
suppressWarnings(k2pdata$ldepth<-log(k2pdata$depth_meters))
suppressWarnings(k2pdata$temp<-k2pdata$temperature_celsius)
suppressWarnings(k2pdata$temp2<-k2pdata$temperature_celsius^2)
suppressWarnings(k2pdata$temp3<-k2pdata$temperature_celsius^3)
suppressWarnings(k2pdata$ltemp<-log(k2pdata$temperature_celsius))
suppressWarnings(k2pdata$SQRTmoist<-sqrt(k2pdata$moisture_content_percent))
lambdas<-c(Virus=0.2,Bacteria=0.3,Protozoa=0.6,Helminth=0.99) # these lambda values are based on data from the literature (Chauret et al., 1999; Lucena et al., 2004; Ramo et al., 2017; Rose et al., 1996; Tanji et al., 2002; Tsai et al., 1998)
lambda<-as.numeric(lambdas[pathogenType])
results<-data.frame(In_Fecal_Sludge=inFecalSludge,In_Sewage=inSewage,Sludge_Biosolids=NA,Liquid_Effluent=NA,Centralized_LRV=NA)
sketch=jsonlite::read_json(mySketch,simplifyVector = T)
#pData=read.csv(myData,header=T)
sketch$temperature<-as.double(sketch$temperature)
sketch$retentionTime<-as.double(sketch$retentionTime)
sketch$depth<-as.double(sketch$depth)
########((((((((this is the beginning of the old getNodes function))))))))
#res<-suppressWarnings(getNodes(sketch = sketch, nodes = sketch[,-c(2,3)]))
drop <- c("x","y","parents","children")
nodes = sketch[,!(names(sketch) %in% drop)]
nodes$number_inputs<-NA
nodes$number_outputs<-NA
for(i in 1:nrow(sketch)){
nodes$number_inputs[i]<-length(sketch[["parents"]][[i]])
nodes$number_outputs[i]<-length(sketch[["children"]][[i]])
}
nodes$loading_output=NA
sn<-sketch[,c("parents","children")]
sn$me<-as.character(sketch[,c("name")])
numParents<-rep(NA,length(sn[,1]))
rem<-NA;j=0
suppressWarnings(  # this for loop turns all NULL parents and children to NA values, and it counts the number of parents (numParents) each node has
for(i in 1:length(sn[,1])){
numParents[i]<-if(is.null(length(sn[i,1][[1]]))){0}else{length(sn[i,1][[1]])}
if(is.null(sn$parents[[i]]) | rlang::is_empty(sn$parents[[i]])){sn[i,1][[1]]<-NA}
if(is.null(sn$children[[i]]) | rlang::is_empty(sn$children[[i]])){sn[i,2][[1]]<-NA}
if(is.na(sn[[1]][[i]])){
j=j+1;rem[j]<-i
}
}
)
orph<-which(numParents==0)
arrows<-data.frame(us_node=rep(NA,sum(numParents)),ds_node=rep(NA,sum(numParents)))
sn<-sn[-orph,];rownames(sn)<-1:nrow(sn)
m=1
for(i in 1:nrow(sn)){
for(j in 1:length(sn[i,"parents"][[1]])){
arrows$us_node[m]<-sn[i,"parents"][[1]][j]
arrows$ds_node[m]<-sn$me[i]
m=m+1
}
}
arrows$loading<-NA
rownames(nodes)<-nodes$name
arrows$siblings<-nodes[arrows$us_node,"number_outputs"]
arrows$flowtype<-nodes[arrows$ds_node,"matrix"]
arrows$siblings_solid<-NA
arrows$siblings_liquid<-NA
arrows$iamsolid<-NA
for(i in 1:nrow(arrows)){
arrows$siblings_solid[i]<-sum(arrows$flowtype[which(arrows$us_node==arrows$us_node[i])]=="solid")
arrows$siblings_liquid[i]<-sum(arrows$flowtype[which(arrows$us_node==arrows$us_node[i])]=="liquid")
if(arrows$flowtype[i]=="solid"){arrows$iamsolid[i]<-TRUE}else{arrows$iamsolid[i]<-FALSE}
}
####(((((((this is the end of the old getNodes function)))))))
# transform the K2P data and fit the models
# k2pdata<-suppressWarnings(transformData(k2pdata))
fit_ap<-lm(SQRTlrv ~ SQRThrt+temp+factor(pathogen),data=subset(k2pdata,technology_description=="Anaerobic Pond"))
fit_fp<-lm(SQRTlrv ~ lhrt+temp+factor(pathogen),data=subset(k2pdata,technology_description=="Facultative Pond"|technology_description=="Maturation Pond"))
fit_mp<-lm(SQRTlrv ~ lhrt+temp+factor(pathogen),data=subset(k2pdata,technology_description=="Facultative Pond"|technology_description=="Maturation Pond"))
fit_db<-lm(SQRTlrv ~ SQRTht+SQRTmoist+factor(pathogen),data=subset(k2pdata,technology_description=="Sludge Drying Bed"))
fit_tf<-lm(SQRTlrv ~ factor(pathogen),data=subset(k2pdata,technology_description=="Trickling Filter"))
fit_sd<-lm(SQRTlrv ~ factor(pathogen),data=subset(k2pdata,technology_description=="Sedimentation"))
# find the LRVs for each pathogen group, then solve the DAG!
pathogenGroups<-c("Virus","Bacteria","Protozoa","Helminth")
warnings<-vector(mode="character",length=0)
if(results$In_Fecal_Sludge>0 & any(nodes$subType=="fecal sludge")==FALSE){ #if the onsite system produces fecal sludge but the treatment plant does not accept any
results$To_Surface<-results$In_Fecal_Sludge
warnings[length(warnings)+1]<-"Warning: The onsite sanitation technologies in your system produce fecal sludge, but according to your sketch, the treatment plant does not accept fecal sludge."
results$In_Fecal_Sludge<-0
skipFS<-TRUE
}else{skipFS<-FALSE}
if(results$In_Sewage>0 & any(nodes$subType=="sewerage")==FALSE){ #if the onsite system produces sewerage but the treatment plant does not accept any
results$To_Surface<-results$In_Sewage
warnings[length(warnings)+1]<-"Warning: The onsite sanitation technologies in your system produce sewage, but according to your sketch, the treatment plant does not accept sewage."
results$In_Sewage<-0
skipWW<-TRUE
}else{skipWW<-FALSE}
nodes$loading_output<-NA
arrows$loading<-NA
if(skipFS==FALSE){nodes[nodes$subType=="fecal sludge",]$loading_output<-results$In_Fecal_Sludge}
if(skipWW==FALSE){nodes[nodes$subType=="sewerage",]$loading_output<-results$In_Sewage}
####(((((((this is the beginning of the old estimate, or getLRVs function)))))))
# get the LRVs for each node
#nodes<-estimate(nodes,pathogenType=pathogenType)
# transformation of user data to make predictions
nodes$lhrt<-NA
nodes$lhrt[nodes$subType=="anaerobic pond"|nodes$subType=="facultative pond"|nodes$subType=="maturation pond"]<-log(nodes$retentionTime[nodes$subType=="anaerobic pond"|nodes$subType=="facultative pond"|nodes$subType=="maturation pond"])
nodes$SQRThrt<-sqrt(nodes$retentionTime)
nodes$SQRTht<-sqrt(as.double(nodes$holdingTime))
nodes$ldepth<-NA
nodes$ldepth[nodes$subType=="anaerobic pond"|nodes$subType=="facultative pond"|nodes$subType=="maturation pond"]<-log(nodes$depth[nodes$subType=="anaerobic pond"|nodes$subType=="facultative pond"|nodes$subType=="maturation pond"])
nodes$temp<-nodes$temperature
nodes$temp2<-nodes$temperature^2
nodes$temp3<-nodes$temperature^3
nodes$ltemp<-NA
nodes$ltemp[nodes$subType=="sludge drying bed"]<-log(nodes$temperature[nodes$subType=="sludge drying bed"])
nodes$ltemp<-log(nodes$temperature)
nodes$SQRTmoist<-sqrt(as.double(nodes$moistureContent))
nodes$pathogen<-pathogenType
nodes$fit<-0;nodes$upr<-0;nodes$lwr<-0
# execution of models
if(any(nodes$subType=="anaerobic pond")==TRUE){nodes[nodes$subType=="anaerobic pond",c("fit","lwr","upr")]<-predict(fit_ap,nodes[nodes$subType=="anaerobic pond",],interval="confidence")^2}
if(any(nodes$subType=="facultative pond")==TRUE){nodes[nodes$subType=="facultative pond",c("fit","lwr","upr")]<-predict(fit_fp,nodes[nodes$subType=="facultative pond",],interval="confidence")^2}
if(any(nodes$subType=="maturation pond")==TRUE){nodes[nodes$subType=="maturation pond",c("fit","lwr","upr")]<-predict(fit_mp,nodes[nodes$subType=="maturation pond",],interval="confidence")^2}
if(any(nodes$subType=="sludge drying bed")==TRUE){
if(pathogenType=="Virus"){nodes[nodes$subType=="sludge drying bed",c("fit","lwr","upr")]<-1}else{nodes[nodes$subType=="sludge drying bed",c("fit","lwr","upr")]<-predict(fit_db,nodes[nodes$subType=="sludge drying bed",],interval="confidence")^2}
}
if(any(nodes$subType=="trickling filter")==TRUE){
if(pathogenType=="Helminth"){nodes[nodes$subType=="trickling filter",c("fit","lwr","upr")]<-1}else{nodes[nodes$subType=="trickling filter",c("fit","lwr","upr")]<-predict(fit_tf,nodes[nodes$subType=="trickling filter",],interval="confidence")^2}
}
if(any(nodes$subType=="settler/sedimentation")==TRUE){
if(pathogenType=="Protozoa"|pathogenType=="Helminth"){nodes[nodes$subType=="settler/sedimentation",c("fit","lwr","upr")]<-0}else{nodes[nodes$subType=="settler/sedimentation",c("fit","lwr","upr")]<-predict(fit_sd,nodes[nodes$subType=="settler/sedimentation",],interval="confidence")^2}
}
####placeholder LRVs until we get more data into the database####
if(any(nodes$subType=="biogas reactor")==TRUE){nodes[nodes$subType=="biogas reactor",c("fit","lwr","upr")]<-c(1,0,2)}
if(any(nodes$subType=="co-composting")==TRUE){nodes[nodes$subType=="co-composting",c("fit","lwr","upr")]<-c(1,0,2)}
if(any(nodes$subType=="activated sludge")==TRUE){nodes[nodes$subType=="activated sludge",c("fit","lwr","upr")]<-c(1,0,2)}
if(any(nodes$subType=="uasb reactor")==TRUE){nodes[nodes$subType=="uasb reactor",c("fit","lwr","upr")]<-c(1,0,2)}
if(any(nodes$subType=="media filer")==TRUE){nodes[nodes$subType=="media filer",c("fit","lwr","upr")]<-c(1,0,2)}
if(any(nodes$subType=="imhoff tank")==TRUE){nodes[nodes$subType=="imhoff tank",c("fit","lwr","upr")]<-c(1,0,2)}
if(any(nodes$subType=="aerated pond")==TRUE){nodes[nodes$subType=="aerated pond",c("fit","lwr","upr")]<-c(1,0,2)}
if(any(nodes$subType=="ss")==TRUE){nodes[nodes$subType=="ss",c("fit","lwr","upr")]<-c(1,0,2)}
if(any(nodes$subType=="fws")==TRUE){nodes[nodes$subType=="fws",c("fit","lwr","upr")]<-c(1,0,2)}
if(any(nodes$subType=="anaerobic baffled reactor")==TRUE){nodes[nodes$subType=="anaerobic baffled reactor",c("fit","lwr","upr")]<-c(1,0,2)}
####
####(((((((this is the end of the old estimate function)))))))
nodeLRVs<-nodes[,c("name","subType","fit","lwr","upr")]
#######(((((((SOLVE IT SOLVE IT SOLVE IT)))))))
#######(((((((SOLVE IT SOLVE IT SOLVE IT)))))))
#######(((((((SOLVE IT SOLVE IT SOLVE IT)))))))
# solve the DAG
i=1;j=1;stuck=1   # here, j is an index for the nodes, i is an index for the arrows, stuck prevents the loop from getting infinitely stuck
nN<-nodes$name
keepGoing=TRUE
# this next monstrosity of a line finds all arrows who's parents are a source, then divides the parent's source load by the number of siblings to calculate the load in these "special" arrows.
arrows[which(arrows$us_node %in% nodes[nodes$ntype=="source",]$name),]$loading<-nodes[arrows[which(arrows$us_node %in% nodes[nodes$ntype=="source",]$name),]$us_node,]$loading_output/arrows[which(arrows$us_node %in% nodes[nodes$ntype=="source",]$name),]$siblings
while (keepGoing==TRUE){       ##### each loop focuses on a single node (nN[j+1]) and the arrow (i+1) that is going into it
if(any(arrows$ds_node==(nN[j]))==TRUE & is.na(sum(arrows[which(arrows$ds_node==(nN[j])),]$loading))==FALSE){       #2. DO I KNOW THE LOADINGS OF ARROWS COMING INTO ME               # if there are any arrows coming into me (Node nN[j])...
nodes[nN[j],]$loading_output=10^(log10(sum(arrows[which(arrows$ds_node==(nN[j])),]$loading))-nodes[nN[j],]$fit)  # then get the sum of all arrows coming into me (nN[j]), minus my LRV, to calculate my output loading
}
if(arrows[i,]$iamsolid==TRUE & arrows[i,]$siblings_liquid>0){    #CALCULATES THE LOADING IN THIS ARROW     # if this arrow is a solid but has liquid siblings
arrows[i,]$loading=nodes[arrows[i,]$us_node,]$loading_output*lambda/arrows[i,]$siblings_solid          # then use the factor lambda to divide the loading up between liquid vs. solid
}else{
if(arrows[i,]$iamsolid==FALSE & arrows[i,]$siblings_solid>0){   #CALCULATES THE LOADING IN THIS ARROW     # if this arrow is a liquid but has solid siblings
arrows[i,]$loading=nodes[arrows[i,]$us_node,]$loading_output*(1-lambda)/arrows[i,]$siblings_liquid     # then use the factor lambda to divide the loading up between liquid vs. solid
}else{arrows[i,]$loading=nodes[arrows[i,]$us_node,]$loading_output/arrows[i,]$siblings}                  # otherwise this arrow only has siblings that are the same as it (could be liquid or solid, but they're all the same), so just divide the loading by the number of siblings
}
stuck<-stuck+1
if(i==(nrow(arrows))){i=1} else {i=i+1}
if(j==(nrow(nodes))){j=1} else {j=j+1} ;arrows;nodes[,c("subType","loading_output")];i;j;nN[j]
if(stuck==1000){keepGoing = FALSE} else {keepGoing = (any(is.na(arrows$loading)) == TRUE | any(is.na(nodes$loading_output)) == TRUE)}
}
lrv=round(log10(sum(nodes$loading_output[nodes$ntype=="source"])/sum(nodes$loading_output[nodes$ntype=="end use"])),2)
references<-unique(k2pdata[nodes$subType %in% tolower(unique(k2pdata$technology_description)),]$bib_id)
#######(((((((I SOLVED IT!)))))))
#######(((((((I SOLVED IT!)))))))
#######(((((((I SOLVED IT!)))))))
# store the results
#arrowLoads<-solved$arrows
results$Centralized_LRV<-lrv
if(any(nodes$matrix=="liquid")){results$Liquid_Effluent<-nodes[nodes$ntype=="end use" & nodes$matrix=="liquid",]$loading_output}else{results$Liquid_Effluent<-0}
if(any(nodes$matrix=="solid")){results$Sludge_Biosolids<-sum(nodes[nodes$ntype=="end use" & nodes$matrix=="solid",]$loading_output)}else{results$Sludge_Biosolids<-0}
loadings=results
loadings$Percent_Liquid<-round(loadings$Liquid_Effluent/(loadings$Liquid_Effluent+loadings$Sludge_Biosolids)*100,1)
loadings$Percent_Solid<-round(loadings$Sludge_Biosolids/(loadings$Liquid_Effluent+loadings$Sludge_Biosolids)*100,1)
arrows$relativeLoading<-arrows$loading/(results$In_Fecal_Sludge+results$In_Sewage)
arrows$us_node_type<-nodes[arrows$us_node,]$subType
arrows$ds_node_type<-nodes[arrows$ds_node,]$subType
#****#****#****#****#
uPs<-paste(unique(nodes$subType[nodes$ntype=="unit process"]), collapse = ', ')
methods<-paste("treats ",nodes$subType[nodes$ntype=="source"][1],if(length(nodes$subType[nodes$ntype=="source"]==2)){paste(" and",nodes$subType[nodes$ntype=="source"][2])},
" using the following technologies: ",
uPs,".",sep=""
);methods
nodes[nodes$ntype=="unit process",]
#****#****#****#****#
solved<-list(arrows=arrows[,c("us_node","ds_node","loading","flowtype","us_node_type","ds_node_type","relativeLoading")],
nodes=nodes[,c("name","ntype","subType","temperature","retentionTime","depth","useCategory","moistureContent","holdingTime","matrix","loading_output","pathogen")],
loadings=loadings,
references=references)
return(solved)
}
getLRV
getLRV()
devtools::document()
library(devtools)
devtools::document()
library(root)
setwd(pathogenflows)
setwd("pathogenflows")
devtools::document()
devtools::install_github('mverbyla/pathogenflows')
devtools::install_github('mverbyla/pathogenflows')
